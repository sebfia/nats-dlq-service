name: build-dlq-service

on:
  push:
    branches:
      - main
    paths:
      - src/DLQService/*.fsproj
      - src/DLQService/*.fs
      - src/DLQService/Dockerfile
      - src/DLQService/paket.references
      - paket.lock
      - paket.dependencies
      - global.json
      - .github/workflows/build.yml
  workflow_dispatch:

# permissions are needed if pushing to ghcr.io
permissions: 
  packages: write
  contents: write

jobs:
  build-dlq-service:

    name: Build DLQ Service

    runs-on: ubuntu-latest

    strategy:
      matrix:
        dotnet-version: [ '10.0.x' ]
        dotnet-sdk-version: [ 'net10.0' ]
    
    permissions:
      contents: write 
      packages: write
      
    steps:
    - 
      name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    - 
      name: Setup dotnet
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
    -
      name: Put project file and output path into environment variable.
      id: set_env
      run: |
        echo "project_path=./src/DLQService/DLQService.fsproj" >> $GITHUB_OUTPUT
        echo "output_path=./src/DLQService/deploy" >> $GITHUB_OUTPUT
    -
      name: Read Version
      id: version
      run: |
        if [ -f ./src/DLQService/VERSION ]; then
          VER=$(cat ./src/DLQService/VERSION | awk -F. -v OFS=. '{$NF += 1 ; print}')
        else
          VER="0.0.1"
        fi
        echo $VER > ./src/DLQService/VERSION
        echo "build_version=$VER" >> $GITHUB_OUTPUT
    -
      name: Compute cache key for dependencies
      id: cache-key
      run: |
        # Create a hash of dependency files to use as cache key
        # This ensures cache is invalidated when dependencies change
        # Handle missing files gracefully
        HASH_INPUT=""
        for file in paket.lock paket.dependencies global.json .config/dotnet-tools.json; do
          if [ -f "$file" ]; then
            HASH_INPUT="${HASH_INPUT}$(sha256sum "$file" 2>/dev/null || echo "$file:missing")"
          fi
        done
        CACHE_KEY=$(echo -n "$HASH_INPUT" | sha256sum | cut -d' ' -f1)
        echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT
        echo "Cache key computed: $CACHE_KEY"
    - 
      name: Cache .NET tools
      uses: actions/cache@v4
      with:
        path: ~/.dotnet/tools
        key: dotnet-tools-${{ runner.os }}-${{ steps.cache-key.outputs.cache_key }}
        restore-keys: |
          dotnet-tools-${{ runner.os }}-
    - 
      name: Restore dotnet tools (Paket)
      run: |
        dotnet tool restore
        echo "${HOME}/.dotnet/tools" >> $GITHUB_PATH
    -
      name: Cache Paket packages
      uses: actions/cache@v4
      with:
        path: |
          .paket
          paket-files
        key: paket-${{ runner.os }}-${{ steps.cache-key.outputs.cache_key }}
        restore-keys: |
          paket-${{ runner.os }}-
    -
      name: Install nuget packages with paket.
      run: dotnet paket install
    - 
      name: Cache .NET restore
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
        key: dotnet-restore-${{ runner.os }}-${{ steps.cache-key.outputs.cache_key }}
        restore-keys: |
          dotnet-restore-${{ runner.os }}-
    - 
      name: Build project in release mode
      run: |
        dotnet clean ${{ steps.set_env.outputs.project_path }} --configuration Release || true
        dotnet restore ${{ steps.set_env.outputs.project_path }}
        dotnet build --configuration Release --no-incremental ${{ steps.set_env.outputs.project_path }}
    -
      # we need qemu and buildx so we can build multiple platforms later
      name: Set up QEMU
      id: qemu
      uses: docker/setup-qemu-action@v3
    -
      # BuildKit (used with `docker buildx`) is the best way to build images
      name: Set up Docker Buildx
      id: buildx
      uses: docker/setup-buildx-action@v3
    -
      name: Login to GHCR
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - 
      name: BuildAndPush
      uses: docker/build-push-action@v6
      with:
        context: .
        builder: ${{ steps.buildx.outputs.name }}
        file: ./src/DLQService/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        no-cache: true
        tags: |
          ghcr.io/${{ github.repository_owner }}/dlqservice:${{ steps.version.outputs.build_version }}
          ghcr.io/${{ github.repository_owner }}/dlqservice:latest
          ghcr.io/${{ github.repository_owner }}/dlqservice:${{ github.sha }}
        labels: |
          org.opencontainers.image.title=DLQ Service
          org.opencontainers.image.description=Dead Letter Queue service for Mercator
          org.opencontainers.image.version=${{ steps.version.outputs.build_version }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.source=${{ github.repositoryUrl }}
          org.opencontainers.image.url=https://github.com/${{ github.repository }}/tree/main/src/DLQService
    - 
      name: Commit and tag new version and create release
      if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
      env: 
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |        
        t_tag='dlq-service-v${{ steps.version.outputs.build_version }}'
        git config user.name github-actions
        git config user.email github-actions@github.com
        git pull
        git add './src/DLQService/VERSION'
        git commit -m 'Update version for DLQ Service to ${{ steps.version.outputs.build_version }}'
        git push origin main
        git tag -a "$t_tag" -m "Released new version of DLQ Service."
        git push origin "$t_tag"
        gh release create 'dlq-service-${{ steps.version.outputs.build_version }}' \
          -t 'DLQ Service ${{ steps.version.outputs.build_version }}' \
          --generate-notes

